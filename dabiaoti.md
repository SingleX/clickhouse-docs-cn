## 介绍

### ClickHouse 是什么?

ClickHouse 是用于联机分析处理（OLAP）的列式的数据库管理系统（DBMS）。

在一个“正常”的面向行的数据库管理系统中，数据是以如下顺序存储：

```
5123456789123456789     1       Eurobasket - Greece - Bosnia and Herzegovina - example.com      1       2011-09-01 01:03:02     6274717   1294101174      11409   612345678912345678      0       33      6       http://www.example.com/basketball/team/123/match/456789.html http://www.example.com/basketball/team/123/match/987654.html       0       1366    768     32      10      3183      0       0       13      0\0     1       1       0       0                       2011142 -1      0               0       01321     613     660     2011-09-01 08:01:17     0       0       0       0       utf-8   1466    0       0       0       5678901234567890123               277789954       0       0       0       0       0
5234985259563631958     0       Consulting, Tax assessment, Accounting, Law       1       2011-09-01 01:03:02     6320881   2111222333      213     6458937489576391093     0       3       2       http://www.example.ru/         0       800     600       16      10      2       153.1   0       0       10      63      1       1       0       0                       2111678 000       0       588     368     240     2011-09-01 01:03:17     4       0       60310   0       windows-1251    1466    0       000               778899001       0       0       0       0       0
...
```

换句话说，所有与同一行相关的值都被存储在一起。面向行的数据库管理系统举例有：MySQL，PostgreSQL，MS SQL Server 等。

在一个面向列的数据库管理系统中，数据像这样被存储：

```
WatchID:    5385521489354350662     5385521490329509958     5385521489953706054     5385521490476781638     5385521490583269446     5385521490218868806     5385521491437850694   5385521491090174022      5385521490792669254     5385521490420695110     5385521491532181574     5385521491559694406     5385521491459625030     5385521492275175494   5385521492781318214      5385521492710027334     5385521492955615302     5385521493708759110     5385521494506434630     5385521493104611398
JavaEnable: 1       0       1       0       0       0       1       0       1       1       1       1       1       1       0       1       0       0       1       1
Title:      Yandex  Announcements - Investor Relations - Yandex     Yandex — Contact us — Moscow    Yandex — Mission        Ru      Yandex — History — History of Yandex    Yandex Financial Releases - Investor Relations - Yandex Yandex — Locations      Yandex Board of Directors - Corporate Governance - Yandex       Yandex — Technologies
GoodEvent:  1       1       1       1       1       1       1       1       1       1       1       1       1       1       1       1       1       1       1       1
EventTime:  2016-05-18 05:19:20     2016-05-18 08:10:20     2016-05-18 07:38:00     2016-05-18 01:13:08     2016-05-18 00:04:06     2016-05-18 04:21:30     2016-05-18 00:34:16     2016-05-18 07:35:49     2016-05-18 11:41:59     2016-05-18 01:13:32
```

这些例子仅展示了数据的排列顺序。不同列的值被分开存储，同一列的值被存储在一起。面向行的数据库管理系统举例有：`Vertica`,`Paraccel（Actian Matrix）（Amazon Redshift）`,`Sybase IQ`,`Exasol`,`Infobright`,`InfiniDB`,`MonetDB（VectorWise）（Actian Vector）`,`LucidDB`,`SAP HANA`,`Google Dremel`,`Google PowerDrill`,`Druid`,`kdb+` 等。

存储数据的不同顺序更好的适用于不同的场景。数据获取场景涉及到产生了什么样的查询，频率和占比情况；每种类型的查询要读取多少数据——行数，列数和字节数；读取和更新数据的关系；工作数据的大小和本地使用情况；是否使用了事务，以及它们是如何隔离的；对数据复制和逻辑完整性的要求；对每种查询的延迟和吞吐量的要求等等。

系统负载越高，为场景定制系统就越重要，这种定制就越特殊。没有一个系统能同等的适用于显著不同的场景。如果一个系统适用于一组广泛的场景，在高负载下，系统会同样糟糕的处理所有这些场景，或者仅在其中一个场景下工作的很好。

对 OLAP 场景，我们会说以下是正确的：

* 绝大多数的请求是读取
* 数据被大批量的更新（&gt;1000行），而不是单行，或不更新
* 数据被添加进数据库，但不修改
* 对读取，相当大量的行被从数据库抽取，但仅仅是列的一个很小的子集
* 表是宽的，意味着它们包含大量的列
* 


